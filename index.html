<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Roadmap Timeline</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      padding: 30px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }

    h1 {
      color: #2d3748;
      margin-bottom: 25px;
      font-size: 28px;
    }

    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 25px;
      flex-wrap: wrap;
      align-items: center;
    }

    .compact-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: auto;
      padding: 8px 12px;
      background: #f7fafc;
      border-radius: 8px;
      cursor: pointer;
      user-select: none;
    }

    .compact-toggle input[type="checkbox"] {
      cursor: pointer;
    }

    .compact-toggle label {
      cursor: pointer;
      font-size: 14px;
      color: #4a5568;
      font-weight: 600;
    }

    .controls input, .controls select, .controls button {
      padding: 10px 15px;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      font-size: 14px;
      transition: all 0.2s;
    }

    .controls input:focus, .controls select:focus {
      outline: none;
      border-color: #667eea;
    }

    .controls button {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      cursor: pointer;
      font-weight: 600;
    }

    .controls button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }

    .timeline-container {
      overflow-x: auto;
      margin-top: 20px;
    }

    .timeline {
      min-width: 800px;
      position: relative;
      background: white;
    }

    .timeline-grid {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 0;
    }

    .month-background {
      position: absolute;
      top: 0;
      bottom: 0;
      pointer-events: none;
    }

    .month-background.even {
      background: #f7fafc;
    }

    .month-background.odd {
      background: white;
    }

    .grid-line {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 1px;
      pointer-events: none;
    }

    .grid-line.month {
      background: #cbd5e0;
      z-index: 2;
    }

    .grid-line.week {
      background: #e2e8f0;
      z-index: 1;
    }

    .timeline-content {
      position: relative;
      z-index: 3;
    }

    .timeline-header {
      display: flex;
      border-bottom: 2px solid #e2e8f0;
      padding-bottom: 10px;
      margin-bottom: 15px;
      position: sticky;
      top: 0;
      background: white;
      z-index: 10;
    }

    .timeline-month {
      flex: 1;
      text-align: center;
      font-weight: 600;
      color: #4a5568;
      font-size: 13px;
    }

    .timeline-row {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      position: relative;
      height: 36px;
      cursor: move;
      padding-left: 30px;
    }

    .drag-handle {
      position: absolute;
      left: 5px;
      color: #a0aec0;
      cursor: grab;
      font-size: 16px;
    }

    .drag-handle:active {
      cursor: grabbing;
    }

    .timeline-row.dragging {
      opacity: 0.5;
    }

    .timeline-row.drag-over {
      border-top: 3px solid #667eea;
    }

    .task-bar {
      position: absolute;
      height: 32px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      padding: 0 12px;
      cursor: pointer;
      transition: all 0.2s;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .task-bar:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      z-index: 5;
    }

    .tooltip {
      position: absolute;
      background: #2d3748;
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      pointer-events: none;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      opacity: 0;
      transition: opacity 0.2s;
      max-width: 250px;
      word-wrap: break-word;
    }

    .tooltip.visible {
      opacity: 1;
    }

    .tooltip-title {
      font-weight: 600;
      margin-bottom: 4px;
    }

    .tooltip-dates {
      font-size: 11px;
      color: #cbd5e0;
    }

    .task-title {
      color: white;
      font-size: 13px;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: white;
      border-radius: 12px;
      padding: 30px;
      max-width: 500px;
      width: 90%;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }

    .modal-content h2 {
      margin-bottom: 20px;
      color: #2d3748;
    }

    .form-group {
      margin-bottom: 15px;
    }

    .form-group label {
      display: block;
      margin-bottom: 5px;
      color: #4a5568;
      font-weight: 600;
      font-size: 14px;
    }

    .form-group input, .form-group select {
      width: 100%;
      padding: 10px;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      font-size: 14px;
    }

    .color-options {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .color-option {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      cursor: pointer;
      border: 3px solid transparent;
      transition: all 0.2s;
    }

    .color-option:hover {
      transform: scale(1.1);
    }

    .color-option.selected {
      border-color: #2d3748;
      transform: scale(1.1);
    }

    .modal-buttons {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }

    .modal-buttons button {
      flex: 1;
      padding: 12px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-save {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .btn-delete {
      background: #fc8181;
      color: white;
    }

    .btn-cancel {
      background: #e2e8f0;
      color: #4a5568;
    }

    .btn-save:hover, .btn-delete:hover, .btn-cancel:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: #a0aec0;
    }

    .empty-state svg {
      width: 80px;
      height: 80px;
      margin-bottom: 20px;
      opacity: 0.5;
    }
  </style>
</head>
<body>
  <div class="container">
    
    <div class="controls">
      <input type="text" id="taskTitle" placeholder="Task title" style="flex: 2; min-width: 200px;">
      <input type="date" id="startDate">
      <input type="number" id="duration" placeholder="Weeks" min="1" style="width: 100px;">
      <button onclick="addTask()">+ Add Task</button>
      <input type="file" id="csvFile" accept=".csv" style="display: none;" onchange="importCSV(event)">
      <button onclick="document.getElementById('csvFile').click()">üìÅ Import CSV</button>
      <div class="compact-toggle">
        <input type="checkbox" id="compactMode" onchange="toggleCompactMode()">
        <label for="compactMode">Compact View</label>
      </div>
    </div>

    <div class="timeline-container">
      <div id="timeline" class="timeline"></div>
    </div>

    <div id="tooltip" class="tooltip">
      <div class="tooltip-title"></div>
      <div class="tooltip-dates"></div>
    </div>
  </div>

  <div id="modal" class="modal">
    <div class="modal-content">
      <h2>Task Details</h2>
      <div class="form-group">
        <label>Title</label>
        <input type="text" id="editTitle">
      </div>
      <div class="form-group">
        <label>Start Date</label>
        <input type="date" id="editStartDate">
      </div>
      <div class="form-group">
        <label>Duration (weeks)</label>
        <input type="number" id="editDuration" min="1">
      </div>
      <div class="form-group">
        <label>Color</label>
        <div class="color-options" id="colorOptions"></div>
      </div>
      <div class="modal-buttons">
        <button class="btn-save" onclick="saveTask()">Save</button>
        <button class="btn-delete" onclick="deleteTask()">Delete</button>
        <button class="btn-cancel" onclick="closeModal()">Cancel</button>
      </div>
    </div>
  </div>

  <script>
    const colors = [
      '#667eea', '#f093fb', '#4facfe', '#fa709a', '#ff6b6b',
      '#c44569', '#f8b500', '#48bb78', '#ed8936', '#9f7aea'
    ];

    let tasks = [];
    let editingTaskId = null;
    let compactMode = false;

    function loadTasks() {
      const stored = JSON.parse(localStorage.getItem('roadmapTasks') || '[]');
      tasks = stored;
      renderTimeline();
    }

    function saveTasks() {
      localStorage.setItem('roadmapTasks', JSON.stringify(tasks));
    }

    function importCSV(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(e) {
        const text = e.target.result;
        const lines = text.split('\n').filter(line => line.trim());
        
        // Skip header row
        for (let i = 1; i < lines.length; i++) {
          const line = lines[i].trim();
          if (!line) continue;
          
          const parts = line.split(',').map(p => p.trim().replace(/^["']|["']$/g, ''));
          
          if (parts.length >= 3) {
            const title = parts[0];
            const startDate = parts[1];
            const duration = parseInt(parts[2]);
            
            if (title && startDate && duration) {
              tasks.push({
                id: Date.now() + i,
                title,
                startDate,
                duration,
                color: colors[Math.floor(Math.random() * colors.length)]
              });
            }
          }
        }
        
        saveTasks();
        renderTimeline();
        event.target.value = '';
      };
      reader.readAsText(file);
    }

    function addTask() {
      const title = document.getElementById('taskTitle').value.trim();
      const startDate = document.getElementById('startDate').value;
      const duration = parseInt(document.getElementById('duration').value);

      if (!title || !startDate || !duration) {
        alert('Please fill in all fields');
        return;
      }

      const task = {
        id: Date.now(),
        title,
        startDate,
        duration,
        color: colors[Math.floor(Math.random() * colors.length)]
      };

      tasks.push(task);
      saveTasks();
      renderTimeline();

      document.getElementById('taskTitle').value = '';
      document.getElementById('startDate').value = '';
      document.getElementById('duration').value = '';
    }

    function getEndDate(startDate, weeks) {
      const date = new Date(startDate);
      date.setDate(date.getDate() + weeks * 7);
      return date;
    }

    function formatDate(date) {
      return date.toLocaleDateString('en-US', { 
        year: 'numeric', 
        month: 'short', 
        day: 'numeric' 
      });
    }

    function showTooltip(e, task) {
      const tooltip = document.getElementById('tooltip');
      const tooltipTitle = tooltip.querySelector('.tooltip-title');
      const tooltipDates = tooltip.querySelector('.tooltip-dates');
      
      const startDate = new Date(task.startDate);
      const endDate = getEndDate(task.startDate, task.duration);
      
      tooltipTitle.textContent = task.title;
      tooltipDates.textContent = `${formatDate(startDate)} - ${formatDate(endDate)}`;
      
      tooltip.style.left = e.pageX + 10 + 'px';
      tooltip.style.top = e.pageY + 10 + 'px';
      tooltip.classList.add('visible');
    }

    function hideTooltip() {
      const tooltip = document.getElementById('tooltip');
      tooltip.classList.remove('visible');
    }

    function toggleCompactMode() {
      compactMode = document.getElementById('compactMode').checked;
      renderTimeline();
    }

    function tasksOverlap(task1, task2) {
      const start1 = new Date(task1.startDate);
      const end1 = getEndDate(task1.startDate, task1.duration);
      const start2 = new Date(task2.startDate);
      const end2 = getEndDate(task2.startDate, task2.duration);
      
      return start1 < end2 && start2 < end1;
    }

    function groupTasksForCompactView(tasks) {
      // Sort tasks by start date
      const sortedTasks = [...tasks].sort((a, b) => 
        new Date(a.startDate) - new Date(b.startDate)
      );
      
      const groups = [];
      
      sortedTasks.forEach(task => {
        let placed = false;
        
        // Try to place in existing group
        for (let group of groups) {
          let canPlace = true;
          
          // Check if task overlaps with any task in this group
          for (let groupTask of group) {
            if (tasksOverlap(task, groupTask)) {
              canPlace = false;
              break;
            }
          }
          
          if (canPlace) {
            group.push(task);
            placed = true;
            break;
          }
        }
        
        // If couldn't place in any group, create new group
        if (!placed) {
          groups.push([task]);
        }
      });
      
      return groups;
    }

    function getMonthsBetween(start, end) {
      const months = [];
      const current = new Date(start.getFullYear(), start.getMonth(), 1);
      const endMonth = new Date(end.getFullYear(), end.getMonth(), 1);

      while (current <= endMonth) {
        months.push(new Date(current));
        current.setMonth(current.getMonth() + 1);
      }

      return months;
    }

    function renderTimeline() {
      const timeline = document.getElementById('timeline');
      
      if (tasks.length === 0) {
        timeline.innerHTML = `
          <div class="empty-state">
            <svg fill="currentColor" viewBox="0 0 20 20"><path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z"/><path fill-rule="evenodd" d="M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z" clip-rule="evenodd"/></svg>
            <p>No tasks yet. Add your first task to get started!</p>
          </div>
        `;
        return;
      }

      const allDates = tasks.flatMap(t => [
        new Date(t.startDate),
        getEndDate(t.startDate, t.duration)
      ]);
      
      const minDate = new Date(Math.min(...allDates));
      const maxDate = new Date(Math.max(...allDates));
      
      minDate.setDate(minDate.getDate() - 7);
      maxDate.setDate(maxDate.getDate() + 7);

      const months = getMonthsBetween(minDate, maxDate);
      const totalDays = (maxDate - minDate) / (1000 * 60 * 60 * 24);

      // Start building HTML with grid
      let html = '<div class="timeline-grid">';
      
      // Add month backgrounds
      months.forEach((month, index) => {
        const monthStart = new Date(month);
        const monthEnd = new Date(month.getFullYear(), month.getMonth() + 1, 0);
        
        const startOffset = ((monthStart - minDate) / (1000 * 60 * 60 * 24)) / totalDays * 100;
        const endOffset = ((monthEnd - minDate) / (1000 * 60 * 60 * 24)) / totalDays * 100;
        const width = endOffset - startOffset;
        
        html += `<div class="month-background ${index % 2 === 0 ? 'even' : 'odd'}" style="left: ${startOffset}%; width: ${width}%;"></div>`;
      });
      
      // Add month grid lines
      months.forEach(month => {
        const monthDate = new Date(month);
        const offset = ((monthDate - minDate) / (1000 * 60 * 60 * 24)) / totalDays * 100;
        html += `<div class="grid-line month" style="left: ${offset}%;"></div>`;
      });
      
      // Add week grid lines
      const currentWeek = new Date(minDate);
      currentWeek.setDate(currentWeek.getDate() - currentWeek.getDay()); // Start from Sunday
      
      while (currentWeek <= maxDate) {
        const offset = ((currentWeek - minDate) / (1000 * 60 * 60 * 24)) / totalDays * 100;
        if (offset >= 0 && offset <= 100) {
         // html += `<div class="grid-line week" style="left: ${offset}%;"></div>`;
        }
        currentWeek.setDate(currentWeek.getDate() + 7);
      }
      
      html += '</div>';
      
      // Add timeline header
      html += '<div class="timeline-content">';
      html += '<div class="timeline-header">';
      months.forEach(month => {
        const monthName = month.toLocaleString('default', { month: 'short', year: 'numeric' });
        html += `<div class="timeline-month">${monthName}</div>`;
      });
      html += '</div>';

      if (compactMode) {
        const groups = groupTasksForCompactView(tasks);
        
        groups.forEach(group => {
          html += '<div class="timeline-row" style="position: relative; height: 36px; margin-bottom: 8px;">';
          
          group.forEach(task => {
            const taskStart = new Date(task.startDate);
            const taskEnd = getEndDate(task.startDate, task.duration);
            
            const startOffset = ((taskStart - minDate) / (1000 * 60 * 60 * 24)) / totalDays * 100;
            const duration = ((taskEnd - taskStart) / (1000 * 60 * 60 * 24)) / totalDays * 100;

            html += `
              <div class="task-bar" style="left: ${startOffset}%; width: ${duration}%; background: ${task.color};" 
                   onclick="openModal(${task.id})"
                   onmouseenter="showTooltip(event, ${JSON.stringify(task).replace(/"/g, '&quot;')})"
                   onmousemove="showTooltip(event, ${JSON.stringify(task).replace(/"/g, '&quot;')})"
                   onmouseleave="hideTooltip()">
                <div class="task-title">${task.title}</div>
              </div>
            `;
          });
          
          html += '</div>';
        });
      } else {
        tasks.forEach(task => {
          const taskStart = new Date(task.startDate);
          const taskEnd = getEndDate(task.startDate, task.duration);
          
          const startOffset = ((taskStart - minDate) / (1000 * 60 * 60 * 24)) / totalDays * 100;
          const duration = ((taskEnd - taskStart) / (1000 * 60 * 60 * 24)) / totalDays * 100;

          html += `
            <div class="timeline-row" draggable="true" data-task-id="${task.id}" 
                 ondragstart="handleDragStart(event)" 
                 ondragover="handleDragOver(event)" 
                 ondrop="handleDrop(event)" 
                 ondragend="handleDragEnd(event)">
              <span class="drag-handle">‚ãÆ‚ãÆ</span>
              <div class="task-bar" style="left: ${startOffset}%; width: ${duration}%; background: ${task.color};" 
                   onclick="openModal(${task.id})"
                   onmouseenter="showTooltip(event, ${JSON.stringify(task).replace(/"/g, '&quot;')})"
                   onmousemove="showTooltip(event, ${JSON.stringify(task).replace(/"/g, '&quot;')})"
                   onmouseleave="hideTooltip()">
                <div class="task-title">${task.title}</div>
              </div>
            </div>
          `;
        });
      }

      timeline.innerHTML = html;
    }

    function openModal(taskId) {
      const task = tasks.find(t => t.id === taskId);
      if (!task) return;

      editingTaskId = taskId;
      document.getElementById('editTitle').value = task.title;
      document.getElementById('editStartDate').value = task.startDate;
      document.getElementById('editDuration').value = task.duration;

      const colorOptions = document.getElementById('colorOptions');
      colorOptions.innerHTML = colors.map(color => 
        `<div class="color-option ${color === task.color ? 'selected' : ''}" 
              style="background: ${color}" 
              data-color="${color}"
              onclick="selectColor('${color}')"></div>`
      ).join('');

      document.getElementById('modal').classList.add('active');
    }

    function closeModal() {
      document.getElementById('modal').classList.remove('active');
      editingTaskId = null;
    }

    function selectColor(color) {
      document.querySelectorAll('.color-option').forEach(el => {
        el.classList.remove('selected');
      });
      const selectedEl = document.querySelector(`.color-option[style*="${color}"]`);
      if (selectedEl) {
        selectedEl.classList.add('selected');
      }
    }

    function saveTask() {
      const task = tasks.find(t => t.id === editingTaskId);
      if (!task) return;

      task.title = document.getElementById('editTitle').value.trim();
      task.startDate = document.getElementById('editStartDate').value;
      task.duration = parseInt(document.getElementById('editDuration').value);
      
      const selectedColor = document.querySelector('.color-option.selected');
      if (selectedColor) {
        task.color = selectedColor.getAttribute('data-color');
      }

      saveTasks();
      renderTimeline();
      closeModal();
    }

    let draggedTaskId = null;

    function handleDragStart(e) {
      draggedTaskId = parseInt(e.currentTarget.dataset.taskId);
      e.currentTarget.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
    }

    function handleDragOver(e) {
      if (e.preventDefault) {
        e.preventDefault();
      }
      e.currentTarget.classList.add('drag-over');
      e.dataTransfer.dropEffect = 'move';
      return false;
    }

    function handleDrop(e) {
      if (e.stopPropagation) {
        e.stopPropagation();
      }
      
      const dropTaskId = parseInt(e.currentTarget.dataset.taskId);
      
      if (draggedTaskId !== dropTaskId) {
        const draggedIndex = tasks.findIndex(t => t.id === draggedTaskId);
        const dropIndex = tasks.findIndex(t => t.id === dropTaskId);
        
        const draggedTask = tasks[draggedIndex];
        tasks.splice(draggedIndex, 1);
        tasks.splice(dropIndex, 0, draggedTask);
        
        saveTasks();
        renderTimeline();
      }
      
      return false;
    }

    function handleDragEnd(e) {
      e.currentTarget.classList.remove('dragging');
      document.querySelectorAll('.timeline-row').forEach(row => {
        row.classList.remove('drag-over');
      });
    }

    function deleteTask() {
      if (!confirm('Are you sure you want to delete this task?')) return;
      
      tasks = tasks.filter(t => t.id !== editingTaskId);
      saveTasks();
      renderTimeline();
      closeModal();
    }

    document.getElementById('modal').addEventListener('click', (e) => {
      if (e.target.id === 'modal') closeModal();
    });

    loadTasks();
  </script>
</body>
</html>
