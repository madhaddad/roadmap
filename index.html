<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Roadmap Timeline</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      padding: 30px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }

    h1 {
      color: #2d3748;
      margin-bottom: 25px;
      font-size: 28px;
    }

    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 25px;
      flex-wrap: wrap;
      align-items: center;
    }

    .compact-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: auto;
      padding: 8px 12px;
      background: #f7fafc;
      border-radius: 8px;
      cursor: pointer;
      user-select: none;
    }

    .compact-toggle input[type="checkbox"] {
      cursor: pointer;
    }

    .compact-toggle label {
      cursor: pointer;
      font-size: 14px;
      color: #4a5568;
      font-weight: 600;
    }

    .controls input, .controls select, .controls button {
      padding: 10px 15px;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      font-size: 14px;
      transition: all 0.2s;
    }

    .controls input:focus, .controls select:focus {
      outline: none;
      border-color: #667eea;
    }

    .controls button {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      cursor: pointer;
      font-weight: 600;
    }

    .controls button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }

    .timeline-container {
      overflow-x: auto;
      margin-top: 20px;
    }

    .timeline {
      min-width: 800px;
      position: relative;
      background: white;
    }

    .timeline-grid {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 0;
    }

    .month-background {
      position: absolute;
      top: 0;
      bottom: 0;
      pointer-events: none;
    }

    .month-background.even {
      background: #f7fafc;
    }

    .month-background.odd {
      background: white;
    }

    .grid-line {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 1px;
      pointer-events: none;
    }

    .grid-line.month {
      background: #cbd5e0;
      z-index: 2;
    }

    .grid-line.week {
      background: #e2e8f0;
      z-index: 1;
    }

    .timeline-content {
      position: relative;
      z-index: 3;
    }

    .timeline-header {
      display: flex;
      border-bottom: 2px solid #e2e8f0;
      padding-bottom: 10px;
      margin-bottom: 15px;
      position: sticky;
      top: 0;
      background: white;
      z-index: 10;
    }

    .timeline-month {
      flex: 1;
      text-align: center;
      font-weight: 600;
      color: #4a5568;
      font-size: 13px;
    }

    .timeline-row {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      position: relative;
      height: 36px;
      cursor: move;
      padding-left: 30px;
    }

    .drag-handle {
      position: absolute;
      left: 5px;
      color: #a0aec0;
      cursor: grab;
      font-size: 16px;
    }

    .drag-handle:active {
      cursor: grabbing;
    }

    .timeline-row.dragging {
      opacity: 0.5;
    }

    .timeline-row.drag-over {
      border-top: 3px solid #667eea;
    }

    .task-bar {
      position: absolute;
      height: 32px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      padding: 0 12px;
      cursor: pointer;
      transition: all 0.2s;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .task-bar:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      z-index: 5;
    }

    .tooltip {
      position: absolute;
      background: #2d3748;
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      pointer-events: none;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      opacity: 0;
      transition: opacity 0.2s;
      max-width: 320px;
      word-wrap: break-word;
    }

    .tooltip.visible {
      opacity: 1;
    }

    .tooltip-title {
      font-weight: 600;
      margin-bottom: 4px;
    }

    .tooltip-dates {
      font-size: 11px;
      color: #cbd5e0;
    }

    .task-title {
      color: white;
      font-size: 13px;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: white;
      border-radius: 12px;
      padding: 30px;
      max-width: 500px;
      width: 90%;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }

    .modal-content h2 {
      margin-bottom: 20px;
      color: #2d3748;
    }

    .form-group {
      margin-bottom: 15px;
    }

    .form-group label {
      display: block;
      margin-bottom: 5px;
      color: #4a5568;
      font-weight: 600;
      font-size: 14px;
    }

    .form-group input, .form-group select {
      width: 100%;
      padding: 10px;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      font-size: 14px;
    }

    .color-options {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .color-option {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      cursor: pointer;
      border: 3px solid transparent;
      transition: all 0.2s;
    }

    .color-option:hover {
      transform: scale(1.1);
    }

    .color-option.selected {
      border-color: #2d3748;
      transform: scale(1.1);
    }

    .modal-buttons {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }

    .modal-buttons button {
      flex: 1;
      padding: 12px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-save {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .btn-delete {
      background: #fc8181;
      color: white;
    }

    .btn-cancel {
      background: #e2e8f0;
      color: #4a5568;
    }

    .btn-save:hover, .btn-delete:hover, .btn-cancel:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: #a0aec0;
    }

    .empty-state svg {
      width: 80px;
      height: 80px;
      margin-bottom: 20px;
      opacity: 0.5;
    }
  </style>
</head>
<body>
  <div class="container">
    
    <div class="controls">
      <input type="text" id="taskTitle" placeholder="Task title" style="flex: 2; min-width: 200px;">
      <input type="date" id="startDate">
      <input type="number" id="duration" placeholder="Weeks" min="1" style="width: 100px;">
      <button onclick="addTask()">+ Add Task</button>
      <input type="file" id="csvFile" accept=".csv" style="display: none;" onchange="importCSV(event)">
      <button onclick="document.getElementById('csvFile').click()">üìÅ Import CSV</button>
      <div class="compact-toggle">
        <input type="checkbox" id="compactMode" onchange="toggleCompactMode()">
        <label for="compactMode">Compact View</label>
      </div>
    </div>

    <div class="timeline-container">
      <div id="timeline" class="timeline"></div>
    </div>

    <div id="tooltip" class="tooltip">
      <div class="tooltip-title"></div>
      <div class="tooltip-dates"></div>
    </div>
  </div>

  <div id="modal" class="modal">
    <div class="modal-content">
      <h2>Task Details</h2>
      <div class="form-group">
        <label>Title</label>
        <input type="text" id="editTitle">
      </div>
      <div class="form-group">
        <label>Start Date</label>
        <input type="date" id="editStartDate">
      </div>
      <div class="form-group">
        <label>Duration (weeks)</label>
        <input type="number" id="editDuration" min="1">
      </div>
      <div class="form-group">
        <label>Color</label>
        <div class="color-options" id="colorOptions"></div>
      </div>
      <div class="modal-buttons">
        <button class="btn-save" onclick="saveTask()">Save</button>
        <button class="btn-delete" onclick="deleteTask()">Delete</button>
        <button class="btn-cancel" onclick="closeModal()">Cancel</button>
      </div>
    </div>
  </div>

  <script>
    const colors = [
      '#667eea', '#f093fb', '#4facfe', '#fa709a', '#ff6b6b',
      '#c44569', '#f8b500', '#48bb78', '#ed8936', '#9f7aea'
    ];

    let tasks = [];
    let editingTaskId = null;
    let compactMode = false;
    const MS_PER_DAY = 1000 * 60 * 60 * 24;

    // Normalize to YYYY-MM-DD where possible
    function toISODate(value) {
      if (!value) return '';
      // already ISO-like
      if (/^\d{4}-\d{2}-\d{2}$/.test(value)) return value;
      const parsed = new Date(value);
      if (isNaN(parsed)) return '';
      return parsed.toISOString().slice(0, 10);
    }

    function loadTasks() {
      try {
        const stored = JSON.parse(localStorage.getItem('roadmapTasks') || '[]');
        // normalize dates stored from inconsistent sources
        tasks = (Array.isArray(stored) ? stored : []).map(t => {
          // if any task has a startDate that can be parsed, convert to YYYY-MM-DD
          const normalized = toISODate(t.startDate) || t.startDate || '';
          return {
            id: t.id,
            title: t.title || '',
            startDate: normalized,
            duration: Number.isFinite(t.duration) ? t.duration : parseInt(t.duration) || 0,
            color: t.color || colors[Math.floor(Math.random() * colors.length)]
          };
        });
      } catch (err) {
        tasks = [];
      }
      renderTimeline();
    }

    function saveTasks() {
      localStorage.setItem('roadmapTasks', JSON.stringify(tasks));
    }

    function importCSV(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(e) {
        const text = e.target.result;
        const lines = text.split('\n').filter(line => line.trim());

        // Skip header row if present (simple heuristic: detect "title" or "start" in first row)
        let startIndex = 0;
        if (lines.length && /title/i.test(lines[0]) && /start/i.test(lines[0])) {
          startIndex = 1;
        }

        for (let i = startIndex; i < lines.length; i++) {
          const line = lines[i].trim();
          if (!line) continue;

          // handle CSV with commas inside quotes (basic)
          const parts = line.split(',').map(p => p.trim().replace(/^["']|["']$/g, ''));

          if (parts.length >= 3) {
            const title = parts[0];
            const rawStart = parts[1];
            const duration = parseInt(parts[2]);

            const isoDate = toISODate(rawStart);

            // Only import when we have sane values
            if (title && isoDate && Number.isFinite(duration) && duration > 0) {
              tasks.push({
                id: Date.now() + i,
                title,
                startDate: isoDate,
                duration,
                color: colors[Math.floor(Math.random() * colors.length)]
              });
            }
          }
        }

        saveTasks();
        renderTimeline();
        event.target.value = '';
      };
      reader.readAsText(file);
    }

    function addTask() {
      const title = document.getElementById('taskTitle').value.trim();
      const startDateRaw = document.getElementById('startDate').value;
      const duration = parseInt(document.getElementById('duration').value);

      const startDate = toISODate(startDateRaw);

      if (!title || !startDate || !Number.isFinite(duration) || duration < 1) {
        alert('Please fill in all fields with valid values');
        return;
      }

      const task = {
        id: Date.now(),
        title,
        startDate,
        duration,
        color: colors[Math.floor(Math.random() * colors.length)]
      };

      tasks.push(task);
      saveTasks();
      renderTimeline();

      document.getElementById('taskTitle').value = '';
      document.getElementById('startDate').value = '';
      document.getElementById('duration').value = '';
    }

    function getEndDate(startDate, weeks) {
      const date = new Date(startDate);
      if (isNaN(date)) return new Date(NaN);
      date.setDate(date.getDate() + (Number.isFinite(weeks) ? weeks * 7 : 0));
      return date;
    }

    function formatDate(date) {
      if (!(date instanceof Date) || isNaN(date)) return 'Invalid date';
      return date.toLocaleDateString('en-US', { 
        year: 'numeric', 
        month: 'short', 
        day: 'numeric' 
      });
    }

    function showTooltip(e, task) {
      const tooltip = document.getElementById('tooltip');
      const tooltipTitle = tooltip.querySelector('.tooltip-title');
      const tooltipDates = tooltip.querySelector('.tooltip-dates');

      const startDate = new Date(task.startDate);
      const endDate = getEndDate(task.startDate, task.duration);

      tooltipTitle.textContent = task.title || '';
      tooltipDates.textContent = `${formatDate(startDate)} - ${formatDate(endDate)}`;

      tooltip.style.left = (e.pageX + 10) + 'px';
      tooltip.style.top = (e.pageY + 10) + 'px';
      tooltip.classList.add('visible');
    }

    function hideTooltip() {
      const tooltip = document.getElementById('tooltip');
      tooltip.classList.remove('visible');
    }

    function toggleCompactMode() {
      compactMode = document.getElementById('compactMode').checked;
      renderTimeline();
    }

    function tasksOverlap(task1, task2) {
      const start1 = new Date(task1.startDate);
      const end1 = getEndDate(task1.startDate, task1.duration);
      const start2 = new Date(task2.startDate);
      const end2 = getEndDate(task2.startDate, task2.duration);

      if (isNaN(start1) || isNaN(end1) || isNaN(start2) || isNaN(end2)) return false;
      
      return start1 < end2 && start2 < end1;
    }

    function groupTasksForCompactView(tasks) {
      // Sort tasks by start date
      const sortedTasks = [...tasks].sort((a, b) => 
        new Date(a.startDate) - new Date(b.startDate)
      );
      
      const groups = [];
      
      sortedTasks.forEach(task => {
        let placed = false;
        
        // Try to place in existing group
        for (let group of groups) {
          let canPlace = true;
          
          // Check if task overlaps with any task in this group
          for (let groupTask of group) {
            if (tasksOverlap(task, groupTask)) {
              canPlace = false;
              break;
            }
          }
          
          if (canPlace) {
            group.push(task);
            placed = true;
            break;
          }
        }
        
        // If couldn't place in any group, create new group
        if (!placed) {
          groups.push([task]);
        }
      });
      
      return groups;
    }

    function getMonthsBetween(start, end) {
      const months = [];
      const current = new Date(start.getFullYear(), start.getMonth(), 1);
      const endMonth = new Date(end.getFullYear(), end.getMonth(), 1);

      while (current <= endMonth) {
        months.push(new Date(current));
        current.setMonth(current.getMonth() + 1);
      }

      return months;
    }

    function clamp01(v) {
      return Math.max(0, Math.min(100, v));
    }

    function renderTimeline() {
      const timeline = document.getElementById('timeline');
      
      if (!tasks || tasks.length === 0) {
        timeline.innerHTML = `
          <div class="empty-state">
            <svg fill="currentColor" viewBox="0 0 20 20"><path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z"/><path fill-rule="evenodd" d="M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 [...]"/>
            <p>No tasks yet. Add your first task to get started!</p>
          </div>
        `;
        return;
      }

      const allDates = tasks.flatMap(t => {
        const s = new Date(t.startDate);
        const e = getEndDate(t.startDate, t.duration);
        return [s, e];
      }).filter(d => d instanceof Date && !isNaN(d));

      if (allDates.length === 0) {
        timeline.innerHTML = `<div class="empty-state"><p>All task dates are invalid. Please fix task dates.</p></div>`;
        return;
      }

      const minDate = new Date(Math.min(...allDates));
      const maxDate = new Date(Math.max(...allDates));
      
      minDate.setDate(minDate.getDate() - 7);
      maxDate.setDate(maxDate.getDate() + 7);

      // prevent division by zero
      let totalDays = (maxDate - minDate) / MS_PER_DAY;
      if (!Number.isFinite(totalDays) || totalDays <= 0) totalDays = 1;

      const months = getMonthsBetween(minDate, maxDate);

      // Start building HTML with grid
      let html = '<div class="timeline-grid">';
      
      // Add month backgrounds
      months.forEach((month, index) => {
        const monthStart = new Date(month);
        const monthEnd = new Date(month.getFullYear(), month.getMonth() + 1, 0);
        
        const startOffset = clamp01(((monthStart - minDate) / MS_PER_DAY) / totalDays * 100);
        const endOffset = clamp01(((monthEnd - minDate) / MS_PER_DAY) / totalDays * 100);
        const width = Math.max(0, endOffset - startOffset);
        
        html += `<div class="month-background ${index % 2 === 0 ? 'even' : 'odd'}" style="left: ${startOffset}%; width: ${width}%;"></div>`;
      });
      
      // Add month grid lines
      months.forEach(month => {
        const monthDate = new Date(month);
        const offset = clamp01(((monthDate - minDate) / MS_PER_DAY) / totalDays * 100);
        html += `<div class="grid-line month" style="left: ${offset}%;"></div>`;
      });
      
      // Add week grid lines (not appending visually by default)
      const currentWeek = new Date(minDate);
      currentWeek.setDate(currentWeek.getDate() - currentWeek.getDay()); // Start from Sunday
      
      while (currentWeek <= maxDate) {
        const offset = ((currentWeek - minDate) / MS_PER_DAY) / totalDays * 100;
        if (offset >= 0 && offset <= 100) {
         // optionally show weeks
         // html += `<div class="grid-line week" style="left: ${offset}%;"></div>`;
        }
        currentWeek.setDate(currentWeek.getDate() + 7);
      }
      
      html += '</div>';
      
      // Add timeline header
      html += '<div class="timeline-content">';
      html += '<div class="timeline-header">';
      months.forEach(month => {
        const monthName = month.toLocaleString('default', { month: 'short', year: 'numeric' });
        html += `<div class="timeline-month">${monthName}</div>`;
      });
      html += '</div>';

      if (compactMode) {
        const groups = groupTasksForCompactView(tasks);
        
        groups.forEach(group => {
          html += '<div class="timeline-row" style="position: relative; height: 36px; margin-bottom: 8px;">';
          
          group.forEach(task => {
            const taskStart = new Date(task.startDate);
            const taskEnd = getEndDate(task.startDate, task.duration);

            if (isNaN(taskStart) || isNaN(taskEnd)) return;
            
            const startOffset = clamp01(((taskStart - minDate) / MS_PER_DAY) / totalDays * 100);
            const duration = clamp01(((taskEnd - taskStart) / MS_PER_DAY) / totalDays * 100);

            html += `
              <div class="task-bar" style="left: ${startOffset}%; width: ${duration}%; background: ${task.color};" 
                   onclick="openModal(${task.id})"
                   onmouseenter="showTooltip(event, ${JSON.stringify(task).replace(/"/g, '&quot;')})"
                   onmousemove="showTooltip(event, ${JSON.stringify(task).replace(/"/g, '&quot;')})"
                   onmouseleave="hideTooltip()">
                <div class="task-title">${task.title}</div>
              </div>
            `;
          });
          
          html += '</div>';
        });
      } else {
        tasks.forEach(task => {
          const taskStart = new Date(task.startDate);
          const taskEnd = getEndDate(task.startDate, task.duration);

          if (isNaN(taskStart) || isNaN(taskEnd)) {
            // show placeholder row but skip rendering task bar to avoid NaN styles
            html += `
              <div class="timeline-row" draggable="true" data-task-id="${task.id}" 
                   ondragstart="handleDragStart(event)" 
                   ondragover="handleDragOver(event)" 
                   ondrop="handleDrop(event)" 
                   ondragend="handleDragEnd(event)">
                <span class="drag-handle">‚ãÆ‚ãÆ</span>
                <div style="margin-left: 40px; color:#a0aec0">Invalid date</div>
              </div>
            `;
            return;
          }
          
          const startOffset = clamp01(((taskStart - minDate) / MS_PER_DAY) / totalDays * 100);
          const duration = clamp01(((taskEnd - taskStart) / MS_PER_DAY) / totalDays * 100);

          html += `
            <div class="timeline-row" draggable="true" data-task-id="${task.id}" 
                 ondragstart="handleDragStart(event)" 
                 ondragover="handleDragOver(event)" 
                 ondrop="handleDrop(event)" 
                 ondragend="handleDragEnd(event)">
              <span class="drag-handle">‚ãÆ‚ãÆ</span>
              <div class="task-bar" style="left: ${startOffset}%; width: ${duration}%; background: ${task.color};" 
                   onclick="openModal(${task.id})"
                   onmouseenter="showTooltip(event, ${JSON.stringify(task).replace(/"/g, '&quot;')})"
                   onmousemove="showTooltip(event, ${JSON.stringify(task).replace(/"/g, '&quot;')})"
                   onmouseleave="hideTooltip()">
                <div class="task-title">${task.title}</div>
              </div>
            </div>
          `;
        });
      }

      timeline.innerHTML = html;
    }

    function openModal(taskId) {
      const task = tasks.find(t => t.id === taskId);
      if (!task) return;

      editingTaskId = taskId;
      document.getElementById('editTitle').value = task.title || '';
      // normalize into YYYY-MM-DD so the date input is always set correctly
      document.getElementById('editStartDate').value = toISODate(task.startDate) || '';

      document.getElementById('editDuration').value = Number.isFinite(task.duration) && task.duration > 0 ? task.duration : '';

      const colorOptions = document.getElementById('colorOptions');
      colorOptions.innerHTML = colors.map(color => 
        `<div class="color-option ${color === task.color ? 'selected' : ''}" 
              style="background: ${color}" 
              data-color="${color}"
              onclick="selectColor('${color}')"></div>`
      ).join('');

      document.getElementById('modal').classList.add('active');
    }

    function closeModal() {
      document.getElementById('modal').classList.remove('active');
      editingTaskId = null;
    }

    function selectColor(color) {
      document.querySelectorAll('.color-option').forEach(el => {
        el.classList.remove('selected');
      });
      const selectedEl = document.querySelector(`.color-option[data-color="${color}"]`);
      if (selectedEl) {
        selectedEl.classList.add('selected');
      }
    }

    function saveTask() {
      const task = tasks.find(t => t.id === editingTaskId);
      if (!task) return;

      const newTitle = document.getElementById('editTitle').value.trim();
      const newStartRaw = document.getElementById('editStartDate').value;
      const newDuration = parseInt(document.getElementById('editDuration').value);

      const newStart = toISODate(newStartRaw);

      if (!newTitle) {
        alert('Title cannot be empty');
        return;
      }
      if (!newStart) {
        alert('Please provide a valid start date (YYYY-MM-DD)');
        return;
      }
      if (!Number.isFinite(newDuration) || newDuration < 1) {
        alert('Please provide a valid duration (weeks, >= 1)');
        return;
      }

      task.title = newTitle;
      task.startDate = newStart;
      task.duration = newDuration;
      
      const selectedColor = document.querySelector('.color-option.selected');
      if (selectedColor) {
        task.color = selectedColor.getAttribute('data-color');
      }

      saveTasks();
      renderTimeline();
      closeModal();
    }

    let draggedTaskId = null;

    function handleDragStart(e) {
      draggedTaskId = parseInt(e.currentTarget.dataset.taskId);
      e.currentTarget.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
    }

    function handleDragOver(e) {
      if (e.preventDefault) {
        e.preventDefault();
      }
      e.currentTarget.classList.add('drag-over');
      e.dataTransfer.dropEffect = 'move';
      return false;
    }

    function handleDrop(e) {
      if (e.stopPropagation) {
        e.stopPropagation();
      }
      
      const dropTaskId = parseInt(e.currentTarget.dataset.taskId);
      
      if (draggedTaskId !== dropTaskId) {
        const draggedIndex = tasks.findIndex(t => t.id === draggedTaskId);
        const dropIndex = tasks.findIndex(t => t.id === dropTaskId);
        
        const draggedTask = tasks[draggedIndex];
        tasks.splice(draggedIndex, 1);
        tasks.splice(dropIndex, 0, draggedTask);
        
        saveTasks();
        renderTimeline();
      }
      
      return false;
    }

    function handleDragEnd(e) {
      e.currentTarget.classList.remove('dragging');
      document.querySelectorAll('.timeline-row').forEach(row => {
        row.classList.remove('drag-over');
      });
    }

    function deleteTask() {
      if (!confirm('Are you sure you want to delete this task?')) return;
      
      tasks = tasks.filter(t => t.id !== editingTaskId);
      saveTasks();
      renderTimeline();
      closeModal();
    }

    document.getElementById('modal').addEventListener('click', (e) => {
      if (e.target.id === 'modal') closeModal();
    });

    loadTasks();
  </script>
</body>
</html>
